/**
 *
 * File name:        	encoder.c
 * File description: 	File containing the methods for the reading
 * 						of an incremental, 3-pin, encoder.
 *
 *
 * Authors:          	Bruno de Souza Ferreira
 * 						Guilherme Kairalla Kolotelo
 * 						Guilherme Bersi Pereira
 *
 * Creation date:    	10Jun2016
 * Revision date:    	20Jun2016
 *
 */


/* Project Includes */
#include "encoder.h"
#include "hal/target_pins.h"
#include "hal/driver/driver.h"

/* SDK Includes */
#include "fsl_tpm_hal.h"
#include "fsl_tpm_driver.h"
#include "fsl_clock_manager.h"
#include "fsl_port_hal.h"
#include "fsl_gpio_hal.h"
#include "fsl_interrupt_manager.h"
#include "fsl_pwm_driver.h"

/* Defines */
/* Maximum number of pulses to be counted in the defined acquisition period before resetting */
#define ENCODER_MAX_PULSE_COUNT		0xFFFF
/* Encoder pulse count */
#define ENCODER_PULSE_COUNT			1024
/* Acquisition period, should be same as cyclic executive period */
#define ENCODER_ACQ_PERIOD_MS		10
/* Pi */
#define ENCODER_CONST_PI			3.14159

/* Global variables: */
/* Measured pulses per second */
uint32_t uiEncoderPulsesPerSecond = 0;
/* Direction of quadrature, 0 or 1 */
uint32_t uiEncoderDirection = 0;
/* Angular position, in 1000*degrees */
uint32_t uiEncoderPosition1000 = 0;


extern void ENCODER_CHA_IRQ_HANDLER()
{
	TPM_DRV_IRQHandler(TPM2_IDX);
	GPIO_HAL_TogglePinOutput(GPIOB, 19);
	GPIO_HAL_TogglePinOutput(GPIOB, 18);
	//GPIO_HAL_TogglePinOutput(GPIOD, 1);
}
extern void ENCODER_CHO_IRQ_HANDLER()
{
	PORT_HAL_ClearPinIntFlag(PORTD, 0);
	GPIO_HAL_TogglePinOutput(GPIOB, 19);
	GPIO_HAL_TogglePinOutput(GPIOB, 18);
}


/**
 * Method name:			ENCODER_CHA_IRQ_HANDLER
 * Method description:	Channel A IRQ handler
 * Input params:      	n/a
 * Output params:     	n/a
 */
//extern void ENCODER_CHA_IRQ_HANDLER()
//{
//	TPM_DRV_IRQHandler(ENCODER_CHA_TPM_INSTANCE);
//	uiEncoderPulsesPerSecond = (1000*TPM_HAL_GetCounterVal(ENCODER_CHA_TPM_BASE))/ENCODER_ACQ_PERIOD_MS;
//	uiEncoderDirection = TPM_HAL_GetCounterVal(ENCODER_CHA_TPM_BASE) > TPM_HAL_GetCounterVal(ENCODER_CHB_TPM_BASE) ? 1 : 0;
//	uiEncoderPosition1000 = 360000*TPM_HAL_GetCounterVal(ENCODER_CHA_TPM_BASE)/ENCODER_MAX_PULSE_COUNT;
//	encoder_resetCounter();
//}


/**
 * Method name:			ENCODER_CHO_IRQ_HANDLER
 * Method description:	Channel O IRQ handler
 * Input params:      	n/a
 * Output params:     	n/a
 */
//extern void ENCODER_CHO_IRQ_HANDLER()
//{
//	PORT_HAL_ClearPinIntFlag(PORTD, 0);
//	encoder_resetCounter();
//}

/**
 * Method name:			encoder_initEncoder
 * Method description:	Initializes the encoder for an incremental 3-pin encoder
 * Input params:      	n/a
 * Output params:     	n/a
 */
void encoder_initEncoder()
{
	///////////////////////////////////////////////////////////////////////////////////////
	// LED for testing
	CLOCK_SYS_EnablePortClock(PORTB_IDX);
	//CLOCK_SYS_EnablePortClock(PORTD_IDX);
	//CLOCK_SYS_EnablePortClock(PORTE_IDX);
	PORT_HAL_SetMuxMode(PORTB, 18, 1);
	PORT_HAL_SetMuxMode(PORTB, 19, 1);
	//PORT_HAL_SetMuxMode(PORTD, 1, 1);
	GPIO_HAL_SetPinDir(GPIOB, 18, kGpioDigitalOutput);
	GPIO_HAL_SetPinDir(GPIOB, 19, kGpioDigitalOutput);
	//GPIO_HAL_SetPinDir(GPIOD, 1,  kGpioDigitalOutput);
	//(PORTA_BASE + (uiEncoderPortInstance << 12));
	///////////////////////////////////////////////////////////////////////////////////////

	/* Configure Channel PORTs */
	CLOCK_SYS_EnablePortClock(ENCODER_CHA_PORT_INSTANCE);
	CLOCK_SYS_EnablePortClock(ENCODER_CHB_PORT_INSTANCE);
	PORT_HAL_SetMuxMode(ENCODER_CHA_PORT_BASE, ENCODER_CHA_PIN_NUMBER, ENCODER_CHA_PORT_ALT);
	PORT_HAL_SetMuxMode(ENCODER_CHB_PORT_BASE, ENCODER_CHB_PIN_NUMBER, ENCODER_CHB_PORT_ALT);

	/* Configure external clock source for TPM modules */
	SIM_HAL_SetTpmExternalClkPinSelMode(SIM, ENCODER_CHA_TPM_INSTANCE, ENCODER_CHA_FTM_CLKIN);
	SIM_HAL_SetTpmExternalClkPinSelMode(SIM, ENCODER_CHB_TPM_INSTANCE, ENCODER_CHB_FTM_CLKIN);

	/* Will be using USB serial over OpenSDA, must enable Debug Mode */
	tpm_general_config_t config=
	{
			.isDBGMode = true
	};
	TPM_DRV_Init(ENCODER_CHA_TPM_INSTANCE, &config);
	TPM_DRV_Init(ENCODER_CHB_TPM_INSTANCE, &config);

	NVIC_EnableIRQ(ENCODER_INTERRUPT_IRQn);

	TPM_HAL_SetClockDiv(ENCODER_CHA_TPM_BASE, kTpmDividedBy1);
	TPM_HAL_SetClockDiv(ENCODER_CHB_TPM_BASE, kTpmDividedBy1);

	TPM_HAL_SetMod(ENCODER_CHA_TPM_BASE, ENCODER_MAX_PULSE_COUNT);
	TPM_HAL_SetMod(ENCODER_CHB_TPM_BASE, ENCODER_MAX_PULSE_COUNT);

	TPM_HAL_ClearCounter(ENCODER_CHA_TPM_BASE);
	TPM_HAL_ClearCounter(ENCODER_CHB_TPM_BASE);

	/* Enable Timer Overflow Interrupt for module ENCODER_INTERRUPT_TPM_INSTANCE */
	TPM_DRV_SetTimeOverflowIntCmd(ENCODER_INTERRUPT_TPM_INSTANCE, true);

	/* Set TPM clock to external for both channels */
	TPM_HAL_SetClockMode(ENCODER_CHA_TPM_BASE, kTpmClockSourceExternalClk);
	TPM_HAL_SetClockMode(ENCODER_CHB_TPM_BASE, kTpmClockSourceExternalClk);


	CLOCK_SYS_EnablePortClock(ENCODER_CHO_PORT_INSTANCE);
	PORT_HAL_SetMuxMode(ENCODER_CHO_PORT_BASE, ENCODER_CHO_PIN_NUMBER, kPortMuxAsGpio);
	PORT_HAL_SetPinIntMode(ENCODER_CHO_PORT_BASE, ENCODER_CHO_PIN_NUMBER, kPortIntRisingEdge);
	//NVIC_EnableIRQ(ENCODER_CHO_IRQn);


}

/**
 * Method name:			encoder_enableCounter
 * Method description:	Enables the counter
 * Input params:      	n/a
 * Output params:     	n/a
 */
void encoder_enableCounter()
{
	TPM_HAL_SetClockMode(ENCODER_CHA_TPM_BASE, kTpmClockSourceExternalClk);
	TPM_HAL_SetClockMode(ENCODER_CHB_TPM_BASE, kTpmClockSourceExternalClk);
}

/**
 * Method name:			encoder_disableCounter
 * Method description:	Disables the counter
 * Input params:      	n/a
 * Output params:     	n/a
 */
void encoder_disableCounter()
{
	TPM_HAL_SetClockMode(ENCODER_CHA_TPM_BASE, kTpmClockSourceNoneClk);
	TPM_HAL_SetClockMode(ENCODER_CHB_TPM_BASE, kTpmClockSourceNoneClk);
	encoder_resetCounter();
}

/**
 * Method name:			encoder_resetCounter
 * Method description:	Resets the counter
 * Input params:      	n/a
 * Output params:     	n/a
 */
void encoder_resetCounter()
{
	TPM_HAL_ClearCounter(ENCODER_CHA_TPM_BASE);
	TPM_HAL_ClearCounter(ENCODER_CHB_TPM_BASE);
}

/**
 * Method name:			encoder_enableChAInterrupt
 * Method description:	Enables the interrupt on Channel A
 * Input params:      	n/a
 * Output params:     	n/a
 */
void encoder_enableChAInterrupt()
{
	TPM_DRV_SetTimeOverflowIntCmd(ENCODER_INTERRUPT_TPM_INSTANCE, true);
}

/**
 * Method name:			encoder_disableChAInterrupt
 * Method description:	Disables the interrupt on channel A
 * Input params:      	n/a
 * Output params:     	n/a
 */
void encoder_disableChAInterrupt()
{
	TPM_DRV_SetTimeOverflowIntCmd(ENCODER_INTERRUPT_TPM_INSTANCE, false);
}

/**
 * Method name:			encoder_enableChOInterrupt
 * Method description:	Enables the interrupt on Channel O
 * Input params:      	n/a
 * Output params:     	n/a
 */
void encoder_enableChOInterrupt()
{
	NVIC_EnableIRQ(ENCODER_CHO_IRQn);
}

/**
 * Method name:			encoder_disableChOInterrupt
 * Method description:	Disables the interrupt on channel O
 * Input params:      	n/a
 * Output params:     	n/a
 */
void encoder_disableChOInterrupt()
{
	NVIC_DisableIRQ(ENCODER_CHO_IRQn);
}


/* Data retrieval methods */


/**
 * Method name:			encoder_getAngularPositionDegree
 * Method description:	Returns the angular position of the encoder in degrees
 * Input params:      	n/a
 * Output params:     	double = Angular position of the encoder in degrees
 */
double encoder_getAngularPositionDegree()
{
	return ((double)uiEncoderPosition1000)/1000;
}

/**
 * Method name:			encoder_getAngularPositionRad
 * Method description:	Returns the angular position of the encoder in radians
 * Input params:      	n/a
 * Output params:     	double = Angular position of the encoder in radians
 */
double encoder_getAngularPositionRad()
{
	return 2*ENCODER_CONST_PI*((double)uiEncoderPosition1000)/360000;
}

/**
 * Method name:			encoder_getAngularVelocityRadPerSec
 * Method description:	Returns the angular velocity of the encoder in Rad/s
 * Input params:      	n/a
 * Output params:     	double = Angular velocity of the encoder in Rad/s
 */
double encoder_getAngularVelocityRadPerSec()
{
	return 2*ENCODER_CONST_PI*((double)uiEncoderPulsesPerSecond/ENCODER_MAX_PULSE_COUNT);
}

/**
 * Method name:			encoder_getAngularVelocityRPM
 * Method description:	Returns the angular velocity of the encoder in RPM
 * Input params:      	n/a
 * Output params:     	double = Angular velocity of the encoder in RPM
 */
double encoder_getAngularVelocityRPM()
{
	return 60*((double)uiEncoderPulsesPerSecond/ENCODER_MAX_PULSE_COUNT);
}

/**
 * Method name:			encoder_getDirection
 * Method description:	Returns the direction the encoder is spinning
 * Input params:      	n/a
 * Output params:     	int = Direction (0 or 1)
 */
int encoder_getDirection()
{
	return (int)uiEncoderDirection;
}








