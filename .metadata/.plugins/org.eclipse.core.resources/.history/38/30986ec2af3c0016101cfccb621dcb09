

/* System includes */
#include "fsl_debug_console.h"
#include "fsl_device_registers.h"
#include "fsl_clock_manager.h"
#include "fsl_port_hal.h"
#include "fsl_gpio_hal.h"

/* Project includes */
#include "hal/mcg/mcg.h"
#include "hal/util/tc_hal.h"
#include "hal/encoder/encoder.h"
#include "hal/driver/driver.h"
#include "hal/controller/controller.h"
#include "hal/hmi/hmi.h"

#include "fsl_tpm_hal.h"

/* Defines */
/* Cyclic executive period in microseconds */
#define CYCLIC_EXECUTIVE_PERIOD         20 * 1000

/* Globals */
volatile unsigned int uiFlagNextPeriod = 0;         /* cyclic executive flag */

/* PID controller globals */
/* HMI will send  dSensorVelocity, dSensorDirection, dSensorPosition*/
double dSensorVelocity = 0, dSensorDirection = 0, dSensorPosition = 0;
double dActuatorValue = 0, dErrorCurrent = 0, dReferenceVelocity = 40, dReferenceDirection = 1;
double dKp = 17, dKi = 1.2, dKd = 0, dMaxSumError = 100;
double dMaxMotorSpeed = 2100*ENCODER_CONST_2PI/60;
t_PID_Data pidData;

void main_cyclicExecuteIsr(void)
{
    /* set the cyclic executive flag */
    uiFlagNextPeriod = 1;
}

int boardInit()
{
    mcg_clockInit();
}

int peripheralInit()
{
	/* Configure Red LED and pin for status and timing analysis */
	CLOCK_SYS_EnablePortClock(PORTB_IDX);
	PORT_HAL_SetMuxMode(PORTB, 18, 1);
	PORT_HAL_SetMuxMode(PORTB, 8, 1);
	GPIO_HAL_SetPinDir(GPIOB, 18, kGpioDigitalOutput);
	GPIO_HAL_SetPinDir(GPIOB, 8, kGpioDigitalOutput);


	/* Comm init */
	//debugUart_init();
	hmi_init();

	/* Device init */
	encoder_initEncoder();
	driver_initDriver();
	controller_initPID(&pidData);

	/* Cyclic executive init */
	tc_installLptmr0(CYCLIC_EXECUTIVE_PERIOD, main_cyclicExecuteIsr);
}

int main(void)
{
	/* Initialization routines */
    boardInit();
    peripheralInit();

    /* Presets */
	controller_setKp(&pidData, dKp);
	controller_setKi(&pidData, dKi);
	controller_setKd(&pidData, dKd);
	controller_setMaxSumError(&pidData, dMaxSumError);


    for (;;) {
    	/* Blink status LED */
    	PTB_BASE_PTR->PTOR = 1 << 18;
    	/* Set PTB8 for timing analysis */
    	PTB_BASE_PTR->PTOR = 1 << 8;;

    	/* Measure motor speed and direction */
    	encoder_takeMeasurement();


    	dSensorVelocity = encoder_getAngularVelocityRad();
    	dSensorPosition = encoder_getAngularPositionDegree();

    	/* Execute PID calculations */
    	dActuatorValue = 100*controller_PIDUpdate(&pidData, dSensorVelocity, dReferenceVelocity)/dMaxMotorSpeed;
    	// dActuatorValue must go from -100 to 100. Direction is set by dReferenceDirection

    	/* Actuate motor */
    	driver_setDriver(dActuatorValue);

    	/* Process serial communication */
    	hmi_receive();
    	hmi_transmit(dSensorVelocity, dSensorPosition, dActuatorValue);

    	/* Clear PTB8 for timing analysis */
    	PTB_BASE_PTR->PTOR = 1 << 8;
    	while(!uiFlagNextPeriod);
    	uiFlagNextPeriod = 0;

    }

    return 0;
}
////////////////////////////////////////////////////////////////////////////////
// EOF
////////////////////////////////////////////////////////////////////////////////
