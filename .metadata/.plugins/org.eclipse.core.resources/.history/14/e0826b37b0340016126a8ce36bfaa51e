
#include "encoder.h"

#include "fsl_tpm_hal.h"
#include "fsl_tpm_driver.h"
#include "fsl_clock_manager.h"
#include "fsl_port_hal.h"
#include "fsl_gpio_hal.h"
#include "fsl_interrupt_manager.h"
#include "fsl_pwm_driver.h"

// Maximum number of pulses to be counted in the defined acquisition period
//uint16_t uiEncoderMaxPulseCount = 0xFFFF;
#define ENCODER_MAX_PULSE_COUNT		0xFFFF
// Acquisition period, should be same as cyclic executive period
//uint32_t uiEncoderAcqPeriod_ms = 1000;
#define ENCODER_ACQ_PERIOD_MS		1000
// Measured Angular Velocity
uint32_t uiEncoderPulsesPerSecond = 0;
// Direction of quadrature
uint32_t uiEncoderDirection = 0;
//PTC12(J2 01) and PTC13(J2 03)
#define ENCODER_CHA_PORT_INSTANCE		PORTC_IDX
#define ENCODER_CHA_PORT_BASE			PORTC
#define ENCODER_CHA_PORT_ALT			4U
#define ENCODER_CHA_PIN_NUMBER			12U
#define ENCODER_CHA_TPM_INSTANCE		TPM2_IDX
#define ENCODER_CHA_TPM_BASE			TPM2

#define ENCODER_CHB_PORT_INSTANCE		PORTC_IDX
#define ENCODER_CHB_PORT_BASE			PORTC
#define ENCODER_CHB_PORT_ALT			4U
#define ENCODER_CHB_PIN_NUMBER			13U
#define ENCODER_CHB_TPM_INSTANCE		TPM1_IDX
#define ENCODER_CHB_TPM_BASE			TPM1

// O channel on PTD0 for interrupt


extern void TPM2_IRQHandler()
{
	TPM_DRV_IRQHandler(TPM2_IDX);
	GPIO_HAL_TogglePinOutput(GPIOB, 19);
	GPIO_HAL_TogglePinOutput(GPIOB, 18);
	//GPIO_HAL_TogglePinOutput(GPIOD, 1);
}
/*
extern void TPM2_IRQHandler()
{
	TPM_DRV_IRQHandler(TPM2_IDX);
	uiEncoderPulsesPerSecond = (1000*TPM_HAL_GetCounter(TPM2))/ENCODER_ACQ_PERIOD_MS;
	uiEncoderDirection = TPM_HAL_GetCounter(TPM2) > TPM_HAL_GetCounter(TPM1) ? 1 : 0;
	TPM_HAL_ClearCounter(TPM2);
	TPM_HAL_ClearCounter(TPM1);
}
*/
// Will be using:
// 		PTC12 @ FTM_CLKIN0 for encoder pin A
// 		PTC13 @ FTM_CLKIN1 for encoder pin B
void encoder_initEncoder()
{
	//Add Error reporting

	// LED for testing
	CLOCK_SYS_EnablePortClock(PORTB_IDX);
	//CLOCK_SYS_EnablePortClock(PORTD_IDX);
	CLOCK_SYS_EnablePortClock(PORTE_IDX);
	PORT_HAL_SetMuxMode(PORTB, 18, 1);
	PORT_HAL_SetMuxMode(PORTB, 19, 1);
	//PORT_HAL_SetMuxMode(PORTD, 1, 1);
	GPIO_HAL_SetPinDir(GPIOB, 18, kGpioDigitalOutput);
	GPIO_HAL_SetPinDir(GPIOB, 19, kGpioDigitalOutput);
	//GPIO_HAL_SetPinDir(GPIOD, 1,  kGpioDigitalOutput);
	//(PORTA_BASE + (uiEncoderPortInstance << 12));

	// tEncoderInputA @ FTM_CLKIN0 for encoder pin A
	// tEncoderInputB @ FTM_CLKIN1 for encoder pin B
	CLOCK_SYS_EnablePortClock(PORTC_IDX);
	//(PORTA_BASE + (uiEncoderPortInstance << 12))
	PORT_HAL_SetMuxMode(PORTC, 12, 4);
	PORT_HAL_SetMuxMode(PORTC, 13, 4);
	// TPM1 for encoder pin A
	// TPM2 for encoder pin B

	CLOCK_SYS_SetTpmSrc(TPM2_IDX, kClockTpmSrcOsc0erClk);

	SIM_HAL_SetTpmExternalClkPinSelMode(SIM, TPM2_IDX, 0);
	SIM_HAL_SetTpmExternalClkPinSelMode(SIM, TPM1_IDX, 1);

	// Will use USB serial over OpenSDA, must enable Debug Mode
	tpm_general_config_t config=
	{
			.isDBGMode = true
	};
	TPM_DRV_Init(TPM2_IDX, &config);
	TPM_DRV_Init(TPM1_IDX, &config);

	//NVIC_SetPriority(TPM2_IRQn, 0x50);
	// Set prescaler to 1
	TPM_HAL_SetClockDiv(TPM2, kTpmDividedBy1);
	TPM_HAL_SetClockDiv(TPM1, kTpmDividedBy1);


	TPM_HAL_SetMod(TPM2, 3);
	TPM_HAL_SetMod(TPM1, 3);

	TPM_HAL_ClearCounter(TPM2);
	TPM_HAL_ClearCounter(TPM1);

	// Enable Timer Overflow Interrupt for Channel A only (TPM2)
	TPM_DRV_SetTimeOverflowIntCmd(TPM2_IDX, true);
	//TPM_DRV_SetTimeOverflowIntCmd(TPM1_IDX, true);

	// Set TPM clock to external
	TPM_HAL_SetClockMode(TPM2, kTpmClockSourceExternalClk);
	TPM_HAL_SetClockMode(TPM1, kTpmClockSourceExternalClk);

	TPM_HAL_GetMod(TPM2);
	TPM_HAL_GetMod(TPM1);
	TPM_HAL_GetMod(TPM2);
	TPM_HAL_GetMod(TPM1);
	TPM_HAL_GetMod(TPM2);
	TPM_HAL_GetMod(TPM1);
	TPM_HAL_GetMod(TPM2);
	TPM_HAL_GetMod(TPM1);
}

void encoder_enableCounter()
{
	TPM_HAL_SetClockMode(TPM2, kTpmClockSourceExternalClk);
	TPM_HAL_SetClockMode(TPM1, kTpmClockSourceExternalClk);
}

void encoder_disableCounter()
{
	TPM_HAL_SetClockMode(TPM2, kTpmClockSourceNoneClk);
	TPM_HAL_SetClockMode(TPM1, kTpmClockSourceNoneClk);
	encoder_resetCounter();
}

void encoder_resetCounter()
{
	TPM_HAL_ClearCounter(TPM2);
	TPM_HAL_ClearCounter(TPM1);
}

void encoder_enableInterrupt()
{
	TPM_DRV_SetTimeOverflowIntCmd(TPM2_IDX, true);
}

void encoder_disableInterrupt()
{
	TPM_DRV_SetTimeOverflowIntCmd(TPM2_IDX, false);
}








